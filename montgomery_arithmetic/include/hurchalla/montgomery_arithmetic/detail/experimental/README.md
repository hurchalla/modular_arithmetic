All files in this experimental directory are expected to be good and immediately usable if desired.  However, I consider them to be experiments that aren't useful enough to be moved outside of an "experimental" directory.

MontyFullRangeMasked.h:
The class MontyFullRangeMasked is usable in the same situations and in the same way as MontyFullRange; i.e. any odd-value is permissable for the modulus of the constructor.  It uses some interesting and unusual optimizations to the Montgomery arithmetic algorithms, in order to (in theory) perform faster multiply and square and fused-multiply/square-add/sub operations.  The speedup comes at the cost of slightly slower simple add and subtract operations.  The speedup also applies only to certain sizes of T.  For a type T that is the same size as the CPU integer registers (e.g. uin64_t on a 64 bit computer) or a type T that is smaller than the register size, there is a decent chance that MontyFullRangeMasked<T> will perform better overall than MontyFullRange<T>, when both are given the same modulus.  This is due to the improved multiply, square, and fused-multiply/square-add/sub functions.  However, the plain add() and subtract() functions in MontyFullRangeMasked<T> will usually be slower than those in MontyFullRange<T>.  For a type T that is larger than the CPU integer register size, you can usually expect MontyFullRangeMasked<T> will perform worse overall than MontyFullRange<T>, and to provide little or no benefit.  If your modulus is small enough to allow use of MontyQuarterRange<T> or MontyHalfRange<T>, you can usually expect those classes to perform better than either MontyFullRange<T> or MontyFullRangeMasked<T>, regardless of the size of T.
To use MontyFullRangeMasked, you would ordinarily declare a variable (using an unsigned integral type T) as follows:
MontgomeryForm<T, MontyFullRangeMasked<T>> mf;
